Objetivo: Implementar tres funciones (def) para estructurar la lógica de un programa que calcula presupuestos y clasifica tareas según su riesgo.
Requisitos del Ejercicio
I. Datos Iniciales
Define las siguientes variables en el ámbito global:
• nombre_proyecto = "Lanzamiento App Móvil"
• lista_tareas = ["Diseño UX", "Integración API", "Test de Seguridad", "Marketing", "Despliegue Final"] (Esta es una lista, que es un tipo de dato mutable
).
• presupuesto_base = 15000 (Este es un entero/flotante, que es un tipo de dato inmutable
).
II. Definición de Funciones
Debes implementar las siguientes tres funciones:
1. asignar_riesgo(tareas_a_analizar)
• Parámetro: Recibe la lista de tareas (tareas_a_analizar).
• Lógica: Itera sobre la lista recibida. Si el nombre de la tarea contiene la subcadena "Seguridad", debe añadir la cadena "(Riesgo CRÍTICO)" al final de esa tarea dentro de la misma lista.
• Comportamiento de la Lista: Como las listas son mutables
, esta función no debe usar return. La modificación de la lista dentro de la función se reflejará en la variable original del ámbito global
.
2. calcular_gasto_adicional(base, riesgo)
• Parámetros: Recibe el presupuesto_base (base) y un factor de riesgo (riesgo, que será un número flotante).
• Lógica:
    ◦ Si el factor de riesgo es mayor a 0.2 (20%), aplica un recargo del 10% adicional a la base
.
    ◦ Si no, devuelve la base sin cambios.
• Valor de Retorno: Debe devolver (return) el nuevo valor del presupuesto calculado
. Como los números son inmutables, la función debe devolver un nuevo valor en lugar de modificar el original
.
3. main()
• Debe contener las llamadas a las funciones anteriores, asegurando que:
    ◦ Llama a asignar_riesgo() para modificar lista_tareas.
    ◦ Llama a calcular_gasto_adicional() y guarda el valor de retorno en una nueva variable, presupuesto_final.
III. Salida Final
Imprime lo siguiente dentro de main():
• La lista de tareas modificada.
• El presupuesto_final.